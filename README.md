Since random numbers are inherently inconsistant, each algorithm was ran a number of times (10+) for each permutation, and the total number of faults for an algorithm were summed and observed. Each algorithm had a range of observed fault sums. FIFO had the largest range, from the low 120's to the high 140's, with most values being in the low to mid 130's. LRU had a tighter range, from the high 110's to the high 130's, with the typical value being in the upper 120's. OPT, as the "optimal" algorithm, had both the tighest observed range and the lowest typical sum, all around 110.

In terms of runtime, FIFO actually has the lowest, with each page being constant time, so linear overall. "Optimal", as implemented here, needs linear time to "see the future" and set all the future times, and then *m* operations to iterate through the queue to find the page to replace, where *m* is the number of page frames. At a glance this might look like O(n^2), but if *m* = *n*, then every page would be in a frame and wouldn't need to be replaced. LRU, as implemented here, has the worst run time; since LRU doesn't know if a particular page *will* be referenced again, it keeps track of all previously used pages. And since pages are sent to the end of the queue after each use, the entire queue must be searched for the page in order to remove it first. All this leads to O(n^2), though this doesn't account for the concept behind LRU that pages that are used are more likely to be used again or optimizations that could be made with the stack (such as allowing updates (unlike standard Java collections), using a tree organization to make updates in O(log(n)) time, or limiting the number of "recently used" pages that are allowed in the stack).

Overall, FIFO performed the worst, but the simplicity of the algorithm and fastest runtime suggests that it might actually be an acceptable option in certain applications, possibly embeded devices. Optimal of course performed the best, but simply keeping track of future values was problematic, never mind how one would even acquire that information. Finally, LRU performed better than FIFO, but not by the margin I would expect. Despite that, I would probably choose to implement LRU for any system I was designing, but try and find ways to manage the refrences better (and probably incorporate second chance).
